diff --git a/src/wasm/wasm-objects-inl.h b/src/wasm/wasm-objects-inl.h
index e1fc2d2410..ec3f04be57 100644
--- a/src/wasm/wasm-objects-inl.h
+++ b/src/wasm/wasm-objects-inl.h
@@ -125,6 +125,7 @@ SMI_ACCESSORS(WasmTableObject, raw_type, kRawTypeOffset)
 // WasmMemoryObject
 ACCESSORS(WasmMemoryObject, array_buffer, JSArrayBuffer, kArrayBufferOffset)
 SMI_ACCESSORS(WasmMemoryObject, maximum_pages, kMaximumPagesOffset)
+ACCESSORS(WasmMemoryObject, host_owned, Object, kHostOwnedOffset)
 OPTIONAL_ACCESSORS(WasmMemoryObject, instances, WeakArrayList, kInstancesOffset)
 
 // WasmGlobalObject
diff --git a/src/wasm/wasm-objects.cc b/src/wasm/wasm-objects.cc
index 27a56695c2..f24d752e34 100644
--- a/src/wasm/wasm-objects.cc
+++ b/src/wasm/wasm-objects.cc
@@ -1223,9 +1223,19 @@ void SetInstanceMemory(Handle<WasmInstanceObject> instance,
 
 }  // namespace
 
+WasmMemoryObject::HostOwnedStoreInfo::~HostOwnedStoreInfo() {
+  // TODO: This is a hack. If the associated ArrayBuffer is still alive,
+  // it will have a dangling pointer as packing store at this point.
+  // (However, that should only matter when mixing Wasm and V8 API.)
+  // To fix, the life time of the backing store should be tied to the buffer.
+  // However, that would require attaching this structue to the buffer
+  // instead of the memory object. Possible with some extra flag bit there?
+  if (free_callback) free_callback(callback_info, data, size);
+}
+
 Handle<WasmMemoryObject> WasmMemoryObject::New(
     Isolate* isolate, MaybeHandle<JSArrayBuffer> maybe_buffer,
-    uint32_t maximum) {
+    uint32_t maximum, std::unique_ptr<HostOwnedStoreInfo> host_owned) {
   Handle<JSArrayBuffer> buffer;
   if (!maybe_buffer.ToHandle(&buffer)) {
     // If no buffer was provided, create a 0-length one.
@@ -1243,6 +1253,17 @@ Handle<WasmMemoryObject> WasmMemoryObject::New(
       isolate->factory()->NewJSObject(memory_ctor, AllocationType::kOld));
   memory_obj->set_array_buffer(*buffer);
   memory_obj->set_maximum_pages(maximum);
+  if (host_owned) {
+    DCHECK(host_owned->memory.is_null());
+    host_owned->data = buffer->backing_store();
+    host_owned->size = buffer->byte_length();
+    auto managed = Managed<HostOwnedStoreInfo>::FromUniquePtr(
+        isolate, sizeof(HostOwnedStoreInfo), std::move(host_owned));
+    memory_obj->set_host_owned(*managed);
+    buffer->set_is_wasm_memory(false);
+  } else {
+    memory_obj->set_host_owned(ReadOnlyRoots(isolate).undefined_value());
+  }
 
   return memory_obj;
 }
@@ -1310,8 +1331,11 @@ int32_t WasmMemoryObject::Grow(Isolate* isolate,
   TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT("v8.wasm"), "GrowMemory");
   Handle<JSArrayBuffer> old_buffer(memory_object->array_buffer(), isolate);
   if (old_buffer->is_shared() && !FLAG_wasm_grow_shared_memory) return -1;
+  HostOwnedStoreInfo* host_owned =
+      Managed<HostOwnedStoreInfo>::cast(memory_object->host_owned())->raw();
   auto* memory_tracker = isolate->wasm_engine()->memory_tracker();
-  if (!memory_tracker->IsWasmMemoryGrowable(old_buffer)) return -1;
+  if (!(host_owned || memory_tracker->IsWasmMemoryGrowable(old_buffer)))
+      return -1;
 
   // Checks for maximum memory size, compute new size.
   uint32_t maximum_pages = wasm::max_mem_pages();
@@ -1335,7 +1359,24 @@ int32_t WasmMemoryObject::Grow(Isolate* isolate,
   // Handle this in the interrupt handler so that it's safe for all the isolates
   // that share this buffer to be updated safely.
   Handle<JSArrayBuffer> new_buffer;
-  if (old_buffer->is_shared()) {
+  if (host_owned) {
+    // TODO: handle shared host-owned memory once the C API supports it.
+    void* new_store = old_buffer->backing_store();
+    if (new_size > old_size) {
+      if (!host_owned->grow_callback) return -1;
+      new_store = host_owned->grow_callback(host_owned->callback_info,
+        old_buffer->backing_store(), old_size, new_size);
+      if (!new_store) return -1;
+    }
+    bool is_external = old_buffer->is_external();
+    DCHECK(is_external);
+    // Disconnect buffer early so GC won't free it.
+    wasm::DetachMemoryBuffer(isolate, old_buffer, false);
+    new_buffer =
+        wasm::SetupArrayBuffer(isolate, new_store, new_size, is_external);
+    host_owned->data = new_store;
+    host_owned->size = new_size;
+  } else if (old_buffer->is_shared()) {
     // Adjust protections for the buffer.
     if (!AdjustBufferPermissions(isolate, old_buffer, new_size)) {
       return -1;
diff --git a/src/wasm/wasm-objects.h b/src/wasm/wasm-objects.h
index 1e6ced0b76..c3ecf4efe0 100644
--- a/src/wasm/wasm-objects.h
+++ b/src/wasm/wasm-objects.h
@@ -327,10 +327,21 @@ class V8_EXPORT_PRIVATE WasmTableObject : public JSObject {
 // Representation of a WebAssembly.Memory JavaScript-level object.
 class WasmMemoryObject : public JSObject {
  public:
+  struct HostOwnedStoreInfo {
+    auto (*grow_callback)(void*, void*, size_t, size_t) -> void* = nullptr;
+    void (*free_callback)(void*, void*, size_t) = nullptr;
+    void* callback_info = nullptr;
+    void* data = nullptr;
+    size_t size = 0;
+
+    ~HostOwnedStoreInfo();
+  };
+
   DECL_CAST(WasmMemoryObject)
 
   DECL_ACCESSORS(array_buffer, JSArrayBuffer)
   DECL_INT_ACCESSORS(maximum_pages)
+  DECL_ACCESSORS(host_owned, Object)
   DECL_OPTIONAL_ACCESSORS(instances, WeakArrayList)
 
   // Dispatched behavior.
@@ -347,7 +358,8 @@ class WasmMemoryObject : public JSObject {
   inline bool has_maximum_pages();
 
   V8_EXPORT_PRIVATE static Handle<WasmMemoryObject> New(
-      Isolate* isolate, MaybeHandle<JSArrayBuffer> buffer, uint32_t maximum);
+      Isolate* isolate, MaybeHandle<JSArrayBuffer> buffer, uint32_t maximum,
+      std::unique_ptr<HostOwnedStoreInfo> host_owned = nullptr);
 
   V8_EXPORT_PRIVATE static MaybeHandle<WasmMemoryObject> New(
       Isolate* isolate, uint32_t initial, uint32_t maximum,
